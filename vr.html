<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/100/three.min.js"></script>
  <!--
  <script src="js/third-party/threejs/DeviceOrientationControls.js"></script>
  <script src="js/third-party/threejs/OrbitControls.js"></script>
  -->

  <script>
  var userAgent = navigator.userAgent.toLowerCase();
	var interval = 0;
	var ax = 0;
	var ay = 0;
	var az = 0;
	var vx = 0;
	var vy = 0;
	var vz = 0;
	var drawX = 0;
	var drawY = 0;
  </script>
</head>
<body>
  <canvas id="myCanvas"></canvas>
  <canvas id="bk_canvas" style="display: none;"></canvas>
  <script>
    // ページの読み込みを待つ
    // サイズを指定
    const width = document.documentElement.clientWidth;
    const height = document.documentElement.clientHeight;

    // レンダラーを作成
    const renderer = new THREE.WebGLRenderer({
      canvas: document.querySelector('#myCanvas')
    });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(width, height);

    // シーンを作成
    const scene = new THREE.Scene();

    // カメラを作成
    var camera = new THREE.PerspectiveCamera(45, width / height);
    camera.position.set(0, 0, +1000);
    // var controls = new THREE.DeviceOrientationControls(camera, true);
    // controls = new THREE.OrbitControls(camera);
    // controls.connect();

    // 箱を作成
    const geometry = new THREE.PlaneGeometry(400, 400);
    const material = new THREE.MeshBasicMaterial( {color: 0xffffff, side: THREE.DoubleSide} );
    const box = new THREE.Mesh(geometry, material);
    scene.add(box);

    tick();

    // 毎フレーム時に実行されるループイベントです
    function tick() {
      //box.rotation.y += 0.01;
      if(isNaN(vx) || isNaN(vy) || isNaN(vz) || isNaN(interval)) {

      }else {
        camera.position.x += vx * interval;
        camera.position.y += vy * interval;
        camera.position.z += vz * interval;
        console.log(camera.position.x);
        console.log(camera.position.y);
        console.log(camera.position.z);
      }
      
      // controls.update();
      renderer.render(scene, camera); // レンダリング

      // requestAnimationFrame(tick);
    }

    if (window.DeviceMotionEvent) {
      window.addEventListener('devicemotion', deviceMotionHandler, false);
      console.log("supported");
    }
    function deviceMotionHandler (event) {
      /*
      ax  = parseFloat(event.acceleration.x);
      ay  = parseFloat(event.acceleration.y);
      az  = parseFloat(event.acceleration.z);
      */
      ax  = event.acceleration.x;
      ay  = event.acceleration.y;
      az  = event.acceleration.z;
    
      /*
        iosとAndroidとで、向きが逆。
        基準はどちらでも良いが、端末を上から見て、
          x:右方向
          y:上方向
          z:手前方向
          を正とするなら、iOS側を補正する。
      */
      if (userAgent.indexOf("iPhone") > 0 || userAgent.indexOf("iPad") > 0 || userAgent.indexOf("iPod") > 0) {
        ax *= -1;
        ay *= -1;
        az *= -1;
      }

      interval = event.interval;
      console.log(interval);
    
      vx += ax * interval;
      vy += ay * interval;
      vz += az * interval;

      console.log(ax);
      console.log(ay);
      console.log(az);
      console.log(vx);
      console.log(vy);
      console.log(vz);

    
      tick();
      
    }
    
    
/*    
    function onmousemove(e) {

        var rect = e.target.getBoundingClientRect();

        // スクリーン上のマウス位置を取得する
        var mouseX = e.clientX - rect.left;
        var mouseY = e.clientY - rect.top;

        // 取得したスクリーン座標を-1〜1に正規化する（WebGLは-1〜1で座標が表現される）
        mouseX =  (mouseX/window.innerWidth)  * 2 - 1;
        mouseY = -(mouseY/window.innerHeight) * 2 + 1;

        // マウスの位置ベクトル
        var pos = new THREE.Vector3(mouseX, mouseY, 1);

        // pos はスクリーン座標系なので、オブジェクトの座標系に変換
        // オブジェクト座標系は今表示しているカメラからの視点なので、第二引数にカメラオブジェクトを渡す
        // new THREE.Projector.unprojectVector(pos, camera); ↓最新版では以下の方法で得る
        pos.unproject(camera);

        // 始点、向きベクトルを渡してレイを作成
        var ray = new THREE.Raycaster(camera.position, pos.sub(camera.position).normalize());

        // 交差判定
        // 引数は取得対象となるMeshの配列を渡す。以下はシーン内のすべてのオブジェクトを対象に。
        var objs = ray.intersectObjects(scene.box);

        //ヒエラルキーを持った子要素も対象とする場合は第二引数にtrueを指定する
        //var objs = ray.intersectObjects(scene.children, true);

        if (obj.length > 0) {
            // 交差していたらobjsが1以上になるので、やりたいことをやる。
            drawX = objs[0].point.x;
            drawY = objs[0].point.y;
        }
    }
    */
  </script>
</body>

</html>
